# 11장. 결제 시스템

## 목표

결제 시스템을 설계하라.

- 결제 시스템은 금전적 가치의 이전을 통해 금융 거래를 정산하는 데 사용되는 모든 시스템
- 안정적이고 확장 가능하며 유연한 결제 시스템은 필수
- 작은 실수로도 상당한 매출 손실이 발생하고 사용자 신뢰를 잃을 수 있다.

## 1단계. 문제 이해 및 설계 범위 확정

- 결제 시스템 종류: 아마존닷컴과 같은 전자상거래 애플리케이션을 위한 결제 백엔드 구축
    - 돈의 흐름에 대한 모든 것을 처리
- 지원하는 결제 방법: 신용 카드 결제만 처리한다고 가정 (원래는 실생활에서 사용 가능한 모든 옵션 지원)
    - 직접 처리 여부: 스트라이프, 브레인트리, 스퀘어 같은 전문 결제 서비스 업체 사용
- 신용 카드 데이터 저장 여부: 카드 번호를 시스템에 직접 저장 X(보안 및 법규 준수에 대한 요건 까다로움), 민감 신용 카드 데이터 처리는 결제 처리 업체에 의존
- 지원 국가: 하나의 통화만 사용한다고 가정(원래는 전 세계적으로 사용 가능한 애플리케이션)
- 하루 결제 건수: 하루 100만 건
- 매월 판매자에게 대금을 지급하는 절차 지원 여부: 지원
- 유의 사항:
    - 결제 시스템은 많은 내부 서비스 및 외부 서비스와 연동하므로, 한 서비스의 장애로 인한 데이터 정합성 이슈 발생 가능
    - 데이터 정합성 조정 작업을 수행하고, 불일치 교정

### 기능 요구사항

- 대금 수신 흐름: 결제 시스템이 판매자를 대신하여 고객으로부터 대금을 수령
- 대금 정산 흐름: 결제 시스템이 전 세계의 판매자에게 제품 판매 대금을 송금

### 비기능 요구사항

- 신뢰성 및 내결함성: 결제 실패는 신중하게 처리
- 내부 서비스와 외부 서비스 간 조정 프로세스: 시스템 간 결제 정보가 일치하는지 비동기적으로 확인

### 개략적인 규모 추정

- 하루 100만 건 처리 == 100만 건 트랜잭션 / 10^5 = 10 TPS
- 일반적인 데이터베이스로 별 문제 없이 처리 가능한 양이므로, 처리 대여폭 대신 결제 트랜잭션의 정확한 처리에 초점을 맞춰 진행

## 2단계. 개략적 설계안 제시 및 동의 구하기

- 대금 수신 흐름: 구매자(신용 카드) -> 전자상거래 웹사이트(은행 계좌)
- 대금 정산 흐름: 전자상거래 웹사이트(은행 계좌) -> 판매자(은행 계좌)

### 대금 수신 흐름

<img alt="image" src="https://github.com/user-attachments/assets/baa0a542-1707-401e-b51d-df104e1b279b">

### 결제 서비스 API

- POST `/v1/payments`
    - 결제 이벤트를 실행
    - 하나의 결제 이벤트는 여러 결제 주문 포함 가능
    - 요청 매개변수
        - buyer_info: 구매자 정보
        - checkout_id: 해당 결제 이벤트를 식별하는 전역적 고유 ID
        - credit_card_info: 암호화된 신용 카드 정보 또는 결제 토큰, PSP마다 다른 값
        - payment_orders: 결제 주문 목록
            - seller_account: 대금 수령할 판매자
            - amount: 전송되어야 할 대금 -> **String**
                - 왜 double이 아닌가?
                    - 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용되는 숫자 정밀도 달라 반올림 오류 유발 가능
                    - 매우 클 수도, 매우 작으 수도 있음
                    - 따라서, 표시하거나 계산에 쓸 때만 숫자로 변환, 전송/저장은 문자열로 보관
            - currency: 주문에 사용된 통화 단위
            - payment_order_id: 해당 주문을 식별하는 전역적 고유 ID
                - **중복 제거 id로 사용(멱등키)**
- GET `/v1/payments/{:id}`
    - payment_order_id가 가리키는 단일 결제 주문의 실행 상태를 반환

### 결제 서비스 데이터 모델

- 테이블
    - 결제 이벤트
    - 결제 주문
- 고려 사항
    - NOT 성능 BUT
        - **안정성이 검증 되었는가? 즉, 다른 대형 금융 회사에서 수년 동안 긍정적인 피드백을 받으면서 사용된 적 있는가?**
        - **모니터링 및 데이터 탐사에 필요한 도구가 풍부하게 지원되는가?**
        - **DBA 채용 시장이 성숙했는가? 숙련된 DBA를 쉽게 채용할 수 있는가?**
    - 일반적으로 NoSQL 보다는 ACID 트랜잭션을 지원하는 전통적인 관계형 DB 선호

#### 결제 이벤트 테이블

| 이름               | 자료형       |
|------------------|-----------|
| checkout_id      | string PK |
| buyer_info       | string    |
| seller_info      | string    |
| credit_card_info | 카드사마다 다름  |
| is_payment_done  | boolean   |

#### 결제 주문 테이블

| 이름                   | 자료형       | description                                                                                                                                                           |
|----------------------|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| payment_order_id     | string PK |                                                                                                                                                                       |
| buyer_account        | string    |                                                                                                                                                                       |
| amount               | string    |                                                                                                                                                                       | 
| currency             | string    |                                                                                                                                                                       |
| checkout_id          | string FK | 한 번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트에는 여러 개의 결제 주문이 포함될 수 있다.                                                                                                      |
| payment_order_status | string    | NOT_STARTED, EXECUTING, SUCCESS, FAILED                                                                                                                               |
| ledger_updated       | boolean   | 동일한 checkout_id 아래 모든 결제 주문이 성공적으로 처리되면 해당 값을 TRUE로 업데이트. 일반적으로 종결되지 않은 결제 주문을 모니터링하기 위해 주기적으로 실행되는 작업을 마련해둔다. 임계값 형태로 설정된 기간이 지나도록 완료되지 않은 결제 주문이 있는 경우 엔지니어에게 경보 알림 |
| wallet_updated       | boolean   | 결제 서비스는 지갑 서비스를 호출하여 판매자 잔액을 업데이트 하고, 해당 필드를 TRUE로 업데이트                                                                                                               |

### 복식부기 원장 시스템

- 복식부기(double-entry) 설계 원칙
    - 모든 결제 시스템에 필수 요소이며 정확한 기록을 남기는 데 핵심적인 역할
    - 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록: 한 계좌는 차감, 다른 계좌는 입금
    - 모든 거래 항목의 합계는 0이어야 한다.
    - **자금 흐름의 시작부터 끝까지 추적 가능하며, 결제 주기 전반에 걸쳐 일관성 보장 가능**

### 외부 결제 페이지

- 신용 카드 정보를 내부에 저장 시 미국의 PCI DSS 같은 복잡한 규정을 준수해야 하므로, 내부에 저장하지 X
- 이를 위해 PSP에서 제공하는 외부 신용 카드 페이지 사용
- PSP가 제공하는 외부 결제 페이지가 직접 고객 카드 정보를 수집

### 대금 정산 흐름

- 대금 수신 흐름과 유사
- 차이점: PSP를 사용하여 구매자의 신용 카드에서 전자상거래 웹사이트 은행 계좌로 돈 이체 (X), 타사 정산 서비스를 사용하여 전자상거래 웹사이트 은행계좌에서 판매자 은행 계좌로 이체 (O)
- 대금 정산도 외상 매입금 지급 서비스 제공업체 이용 (다양한 부기 및 규제 요구사항 존재)

## 3단계. 상세 설계

- PSP 연동
- 조정
- 결제 지연 처리
- 내부 서비스 간 통신
- 결제 실패 처리
- 정확히 한 번 전달
- 일관성
- 보완

### PSP 연동

- 일반적으로 다음 두 가지 방법 중 하나로 결제 시스템을 PSP와 연동
    1. 회사가 민감한 결제 정보를 안전하게 저장할 수 있다면 API를 통해 PSP와 연동 가능

    - 결제 웹페이지를 개발하고, 민감한 결제 정보 수집
    - PSP는 은행 연결, 다양한 카드 유형 지원 역할

    2. 복잡한 규정 및 보안 문제로 인해 민감한 결제 정보 저장 X (대부분 이 방법 사용)

    - PSP는 카드 결제 세부 정보 수집하여 안전하게 저장할 수 있도록 외부 결제 페이지 제공

<img alt="image" src="https://github.com/user-attachments/assets/a2db5660-b717-4e5e-8c6a-6954c014ddd8">

### 조정

- 비동기적으로 통신 시 메시지 전달/응답 반환 보장이 없다.
- 실제로 장애가 발생하면 체계적으로 처리할 수 있는 방법이 있을까? 정확성을 어떻게 보장할까?
- **조정!**
    - 관련 서비스 간 상태를 주기적으로 비교하여 일치 여부 확인
    - 결제 시스템의 마지막 방어선
    - 결제 시스템 내부 일관성 확인 목적으로도 사용 가능
- 방법
    - 매일 밤 PSP나 은행은 고객에게 정산 파일 전송
        - 은행 계좌의 잔액과 하루 동안 해당 계좌에서 발생한 모든 거래 내역 기제
    - 조정 시스템은 정산 파일의 세부 정보를 읽어 원장 시스템과 비교

<img alt="image" src="https://github.com/user-attachments/assets/be8e790d-c32f-4565-8cb4-b6943992771d">

### 결제 지연 처리

- 결제 요청이 오래 걸리는 사례
    - PSP가 해당 결제 요청의 위험성이 높다고 보고 담당자 검토 요구
    - 신용 카드사가 구매 확인 용도로 카드 소유자의 추가 정보를 요청하는 3D 보안 인증 같은 추가 보호 장치 요구
- 구매 페이지가 외부 PSP에 호스팅 되는 경우 다음과 같이 처리
    - PSP는 결제가 대기 상태임을 알리는 상태 정보를 클라이언트에 반환하여 사용자에게 표시
        - 클라이언트는 고객이 현재 상태를 확인할 수 있는 페이지 제공
    - PSP는 우리 회사를 대신하여 대기 중인 결제 진행 상황을 추적하고, 상태 변경 시 PSP에 등록된 웹훅으로 결제 서비스에 알림
        - 결제 요청이 최종적으로 완료되면 PSP는 웹훅을 호출하고, 결제 서비스는 내부 시스템에 기록된 정보를 업데이트하고 고객에게 배송을 완료
    - 일부는 웹훅 대신, 결제 서비스로 하여금 대기 중인 결제 요청 상태를 주기적으로 polling하기도 함

### 내부 서비스 간 커뮤니케이션

#### 동기식 통신

- 동기식 통신에서 한 요청에 응답을 만드는 처리 주기는 관련 서비스가 많을수록 길어짐
- 소규모 시스템에서는 잘 동작하지만, 규모가 커지면 단점 부각
    - 성능 저하: 관련 서비스 중 하나에 발생한 성능 문제가 전체에 영향
    - 장애 격리 곤란: PSP 등 서비스 장애 발생 시 클라이언트는 응답 받지 못함
    - 높은 결합도: 요청 발신자는 수신자를 알아야만 함
    - 낮은 확장성: 큐를 버퍼로 사용하지 않고서는 갑작스러운 트래픽 증가에 대응할 수 있도록 시스템 확장 어려움
    - 의존성 그래프 커지고, 전반적 성능 저하

#### 비동기식 통신

- 트레이드 오프: 설계의 단순성과 데이터 일관성 <-> 시스템 확장성 및 장애 감내 능력
- 비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에 적합한 선택

1. 단일 수신자
    - 각 요청은 하나의 수신자 또는 서비스가 처리
    - 보통 공유 메시지 큐로 구현
    - 큐에는 복수 구독자가 있을 수 있으나 처리된 메시지는 큐에서 바로 제거
2. 다중 수신자
    - 각 요청은 여러 수신자 또는 서버가 처리
    - 카프카가 적합
    - 소비자가 수신한 메시지는 카프카에서 바로 사라지지 않고, 동일한 메시지를 여러 서비스가 받아 처리 가능
    - 결제 시스템 구현에 적합 -> 하나의 요청이 푸시 알림 전송, 재무 보고 업데이트, 분석 결과 업데이트 등의 다양한 용도에 쓰일 수 있음

### 결제 실패 처리

- 안정성 및 결함 내성은 결제 시스템의 핵심적 요구사항
- 모든 결제 시스템은 실패한 결제를 적절히 처리

#### 결제 상태 추적

- 결제 주기의 모든 단계에서 결제 상태를 정확하게 유지
- 실패 발생마다 결재 거래의 현재 상태를 파악하고 재시도 or 환불 여부 판단

#### 재시도 큐 및 실패 메시지 큐

- 재시도 큐: 일시적 오류 같은 재시도 가능 오류는 재시도 큐로 전송
- 실패 메시지 큐: 반복적으로 처리에 실패한 메시지는 실패 메시지 큐로 전송
    - 문제가 있는 메시지를 디버깅하고 격리하여 성공적으로 처리되지 않은 이유를 파악하기 위한 검사에 유용

### 정확히 한 번 전달

- 이중 청구는 치명적이므로 결제 주문이 정확히 한 번만 실행되도록 결제 시스템 설계
- 다음 요건 충족
    1. 최소 한 번은 실행
    2. 최대 한 번 실행

#### 재시도

- 최소 한 번 실행 보장 가능
- **얼마나 간격을 두고 재시도를 할 것인가**
    - 즉시 재시도: 클라이언트는 즉시 요청을 재전송
    - 고정 간격: 재시도 전에 일정 시간 대기
    - 증분 간격: 재시도 전 대기 시간을 특정 양만큼 점진적 증가
    - 지수적 백오프: 재시도 전 대기 시간을 2배 씩 증가
    - 취소: 요청을 철회 (실패가 영구적, 재시도해도 성공 가능성 낮을 때)
- 그러다가, 2번 이상 결제되면? **멱등성!**

#### 멱등성

- 최대 한 번 실행 보장
- 일반적으로 클라이언트가 생성하고 일정 시간 지나면 만료되는 고유한 값을 멱등 키로 사용
- 결제 요청의 멱등성 보장 위해서는 <멱등 키: 값>의 형태로 멱등 키 추가
- 데이터베이스의 고유 키 제약 조건을 활용하여 기본 키를 멱등 키로 사용
  시나리오 1. 고객이 '결제' 버튼을 두 번 클릭
    - 두 번째 요청을 재시도로 처리 -> 요청에 포함된 멱등 키를 이전에 받은 적 있음
    - 그런 경우 결제 시스템은 이전 결제 요청의 가장 최근 상태를 반환
    - n번 요청 시 `492 Too Many Requests` 반환

시나리오 2. PSP가 결제를 성공적으로 처리했지만 네트워크 오류로 응답이 결제 시스템에 전달되지 못하여, 사용자가 '결제' 버튼 다시 클릭

- 결제 서비스는 PSP에 비중복 난수를 전송하고, PSP는 해당 난수에 대응되는 토큰을 반환
- 난수가 결제 주문을 유일하게 식별하고, 토큰은 난수에 일대일로 대응되므로 토큰 또한 결제 주문을 유일하게 식별
- 사용자가 결제 버튼을 다시 눌러도 PSP로 전송되는 토큰이 같으므로, 종전 실행 결과를 반환

### 일관성

- 결제 실행 과정에서 상태 정보를 유지 관리하는 여러 서비스가 호출

1. 결제 서비스는 비중복 난수, 토큰, 결제 주문, 실행 상태 등의 결제 관련 데이터 유지 관리
2. 원장은 모든 회계 데이터를 보관
3. 지갑은 판매자의 계정 잔액을 유지
4. PSP는 결제 실행 상태를 유지
5. 데이터는 안정성을 높이기 위해 여러 데이터베이스 사본에 복제

- 분산 환경에서의 서비스 간 통신 실패로 데이터 불일치 발생 가능성 해결 방안
    - 내부 서비스 간 데이터 일관성 유지: 요청이 '정확히 한 번 처리' 보장
    - 내부 서비스 <-> 외부 서비스 간 데이터 일관성 유지: 멱등성 & 조정 프로세스 활용
    - 데이터 다중화: 복제 지연으로 인한 불일치
        - 주 데이터베이스에서만 읽기와 쓰기 연산 처리
            - 규모 확장성 떨어짐
            - 사본은 데이터 안정성 보장에만 활용, 트래픽 처리 안함
            - 자원 낭비
        - 모든 사본 동기화 보장
            - 합의 알고리즘 사용
            - 합의 기반 분산 데이터베이스 사용

### 결제 보안

- 요청/응답 도청 -> HTTPS 사용
- 데이터 변조 -> 암호화 및 무결성 강화 모니터링
- 중간자 공격 -> 인증서 고정과 함께 SSL 사용
- 데이터 손실 -> 여러 지역에 걸쳐 데이터베이스 복제 및 스냅샷 생성
- DDoS -> 처리율 제한 및 방화벽
- 카드 도난 -> 토큰화. 실제 카드 번호 사용 대신 토큰을 저장하고 결제에 사용
- PCI 규정 준수: PCI DSS는 브랜드 신용 카드를 처리하는 조직을 위한 정보 보안 표준
- 사기 -> 주소 확인, 카드 확인 번호, 사용자 행동 분석 등

## 4단계. 마무리

### 추가 고려사항

- 모니터링: "특정 결제 수단의 평균 승인율은 얼마인가?", "서버의 CPU 사용량은 얼마인가?" 등의 지표 모니터링
- 경보: 비정상적인 상황 발생 시 온콜 중인 개발자에게 알려 신속하게 대응
- 디버깅 도구: 결제 실패 원인 디버깅 쉽도록 결제 거래 상태, 처리 서버 기록, PSP 기록 등 검토 가능한 도구 개발
- 환율: 국제적인 결제 시스템 설계 시 중요한 고려사항
- 지역: 지역마다 가용한 결제 수단 상이
- 현금 결제: 현금 결제가 일반적인 국가 고려
- 구글/애플 페이 연동
