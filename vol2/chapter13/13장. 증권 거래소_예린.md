# 13장. 증권 거래소

## 목표

온라인 증권 거래 시스템을 설계하라.

- 증권 거래소 별 규모, 중요 특징 상이
    - 금융 산업의 수직적 세부노하에 초점을 맞추고 기술적 측면 강조
    - 공정성에 중점
- 사례 기준 대략적 규모
    - 뉴욕 증권 거래소는 하루에 수십 억 건 거래 처리
    - HKEX는 하루 약 2천억 건 주식 거래 처리

## 1단계. 문제 이해 및 설계 범위 확정

- 거래 증권 종류(주식, 옵션, 선물 등): 주식
- 지원하는 주문 유형(새 주문, 주문 취소, 주문 교체 / 지정가 주문, 시장가 주문, 조건부 주문): 새 주문, 체결되지 않은 주문 취소 / 지정가 주문만 가능
- 시간 외 거래 가능 여부: 불가능, 시간 내 거래만 가능
- 기본 기능
    - 새로운 지정가 주문 접수
    - 기존 주문 취소
    - 주문 체결 시 실시간으로 알 수 있어야 함
    - 호가 창 정보는 실시간 갱신되어야 함
        - 호가 창: 매수 및 매도 주문 목록 표시
    - 규제 시설이므로 위험성 점검 가능해야 함
- 사용자 수: 최소 수만명 사용자가 동시 거래 가능
- 증권 가짓수, 주문 수: 최소 100가지 주식 거래가 가능
- 거래소 규모: 거래량 = 하루 수십억 건 주문
- 위험성 점검: 한 사용자가 하루에 거래할 수 있는 애플 주식을 백만 주 이하로 제한한다는 규칙이 있다면 이를 위반하지 않는지 점검하는 등
- 사용자 지갑 관리: 주문 전 자금 확인, 체결되지 않은 주문이 있다면 해당 주문에 이용된 자금은 다른 주문에 사용 불가

### 비기능 요구사항

- 소규모 ~ 중간 규모 정도의 거래소 설계
- 확장성 중요
- 가용성: 최소 99.99%, 매우 중요!
- 결함 내성: 프로덕션 장애 파금 최소화 -> 결함 내성 & 빠른 복구 메커니즘 필요
- 지연 시간: 왕복 지연 시간은 밀리초 수준, p99 지연 시간 중요
    - 왕복 지연 시간 = 주문이 거래소에 들어오는 시점 ~ 주문 체결 사실 반환 시점
    - p99 지연 시간 높음 = 일부 사용자 거래소 이용 경험 저하
- 보안: 계정 관리 시스템을 갖춤
    - 점률 및 규정 준수를 위해 새 계좌 개설 전에 사용자 신원 확인을 위한 Know Your Client(KYC) 확인 수행
    - 시장 데이터가 포함된 웹 페이지 등의 공개 자원은 DDoS 공격을 방지하는 장치 구비 필요

### 개략적 규모 추정

- 100가지 주식, 하루 10억 건의 주문
- 뉴욕증권거래소 영업 시간: 월~금, 9:30 ~ 16:00 (6.5시간)
- QPS = 10억 / (6.5시간 * 3600) = 약 43000
- 최대 QPS = 5 * QPS = 215000
    - 거래량은 장 시작 직후, 장 마감 직전에 훨씬 높음

## 2단계. 개략적 설계안 제시 및 동의 구하기

기본 개념과 용어 먼저 알아보자.

### 증권 거래 101

#### 브로커

- 개인 고객과 거래소 사이에서 중간 다리
- 개인 사용자가 증권을 거래하고 시장 데이터를 확인할 수 있는 편리한 사용자 인터페이스 제공

#### 기관 고객

- 전문 증권 거래 소프트웨어를 사용하여 대량으로 거래
- 기관 고객마다 거래 시스템에 대한 요구사항 다름
- 연기금
    - 안정적 수익 목표
    - 거래 빈도는 낮지만 거래량은 많음
    - 대규모 주문이 시장에 미치는 영향을 최소화하기 위해 주문 분할 같은 기능 필요
- 헤지 펀드
    - 시장 조성을 전문으로 함
    - 수수료 리베이트를 통해 수익을 얻음
    - 낮은 응답 시간으로 거래하길 원함: 일반 사용자들처럼 웹페이지나 모바일 앱에서 시장 데이터를 확인하게 하면 곤란

#### 지정가 주문

- 가격이 고정된 매수 또는 매도 주문
- 시장가 주문과 달리 체결이 즉시 이루어지지 않을 수 있음
- 부분적으로만 체결될 수 있음

#### 시장가 주문

- 가격을 지정하지 않은 주문
- 시장가로 즉시 체결
- 체결은 보장되나 비용 면에서 손해 가능
- 급변하는 특정 시장 상황에 유용

#### 시장 데이터 수준

- 세 가지 가격 정보 등급: L1, L2, L3
- L1 시장 데이터
    - 최고 매수 호가, 매도 호가, 수량 포함
    - 최고 매수 호가: 구매자가 주식에 지불할 의사가 있는 최고 가격
    - 매도 호가: 매도자가 주식을 팔고자 하는 최저 가격
- L2 시장 데이터
    - 깊이: 체결을 기다리는 물량의 호가를 어디까지 보여주는지 나타냄
- L3 시장 데이터
    - 각 주문 가격에 체결을 기다리는 물량 정보까지 보여줌

#### 봉 차트

- 특정 기간 동안의 주가
- 하나의 봉 막대로 일정 시간 간격 동안 시장의 시작가, 종가, 최고가, 최저가 표시
- 일반적으로 지원되는 시간 간격: 1분, 5분, 1시간, 1일, 1주일, 1개월

#### FIX

- Financial Information Exchange Protocol: 금융 정보 교환 프로토콜
- 증권 거래 정보 교환을 위한 기업 중립적 통신 프로토콜

### 개략적 설계안

<img alt="image" src="https://github.com/user-attachments/assets/46a2533c-81c3-473e-9738-deaac07def57">

### API 설계

- 브로커와 클라이언트 게이트웨이 간 인터페이스 명세 작성 by RESTful 컨벤션

#### 주문

- POST `/v1/order`
    - 주문 처리
    - 인증 필요
    - 인자
        - symbol: 주식 나타내는 심볼: String
        - side: 매수/매도: String
        - price: 지정가 주문의 가격: Long
        - orderType: limit(지정가)/market(시장가): String
        - quantity: 주문 수량: Long
    - 응답
        - id: 주문 ID: Long
        - creationTime: 주문이 시스템에 생성된 시간: Long
        - filledQuantity: 집행이 완료된 수량: Long
        - remainingQuantity: 아직 체결되지 않은 주문 수량: Long
        - status: new/canceled/filled: String

#### 집행

- GET `/v1/execution?symbol={symbol}&orderId={orderId}&startTime={startTime}&endTime={endTime}`
    - 집행 정보 질의
    - 인증 필요
    - 응답
        - executions: 범위 내 모든 집행 기록의 배열: Array
        - id: 집행 기록 ID: Long
        - orderId: 주문 ID: Long
        - symbol: 주식 심벌: String
        - side: buy/sell: String
        - price: 체결 가격: String
        - orderType: limit/market: String
        - quantity: 체결 수량: Long

#### 호가 창/주문서

- GET `/v1/marketdata/orderBook/L2?symbol={symbol}&depth={depth}`
    - 주어진 주식 심벌, 깊이에 대한 L2 호가 창 질의 결과 반환
    - 응답
        - bids: 가격과 수량 정보 담은 배열: Array
        - asks: 가격과 수량 정보 담은 배열: Array

#### 가격 변동 이력(봉 차트)

- GET `/v1/marketdata/candles?symbol={symbol}&resolution={resolution}&startTime={startTime}&endTime={endTime}`
    - 주어진 시간 범위, 해상도, 심벌에 대한 봉 차트 데이터 질의 결과 반환
    - 인자
        - resolution: 봉 차트의 윈도우 길이(초 단위): Long
    - 응답
        - candles: 각 봉의 데이터를 담은 배열: Array
        - open: 해당 봉의 시가: Double
        - close: 해당 봉의 종가: Double
        - high: 해당 봉의 고가: Double
        - low: 해당 봉의 저가: Double

### 데이터 모델

#### 상품, 주문, 집행

- 상품: 거래 대항 주식이 가진 속성으로 정의
    - 상품 유형, 거래에 쓰이는 심벌, UI에 표시될 심벌, 결산에 이용되는 통화 단위, 매매 수량 단위, 호가 가격 단위 등
    - 자주 바뀌지 않는 데이터
    - UI 표시를 위한 데이터
    - 아무 데이터베이스에나 저장, 캐시를 적용하기 좋음
- 주문: 매수/매도를 실행하라는 명령
- 집행 기록: 체결이 이루어진 결과
- 모든 주문이 집행되진 않는다. -> 주문:집행 기록 = 1:0~N
- 흐름 별 데이터 저장 방법
    - 중요 거래 경로
        - 주문/집행 기록을 DB에 저장하지 않음
        - 성능을 높이기 위해 메모리에서 거래를 체결하고 하드 디스크나 공유 메모리를 활용하여 주문과 집행 기록을 저장/공유
        - 주문/집행 기록은 빠른 복구를 위해 시퀀서에 저장
        - 데이터 보관은 장 마감 후에 실행
    - 보고 서비스
        - 조정, 세금 보고 등을 위해 데이터베이스에 주문/집행 저장
    - 집행 기록
        - 시장 데이터 프로세서로 전달되어 호가 창/주문서&봉 차트 데이터 재구성에 사용

#### 호가 창

- 특정 증권/금융 상품에 대한 매수/매도 주문 목록
- 가격 수준별로 정리
- 체결 엔진이 빠른 주문 체결을 위해 사용하는 핵심 자료 구조
- 요구사항
    - 일정한 조회 시간: 특정 가격 수준의 주문량 조회, 특정 가격 범위 내의 주문량 조회 등
    - 빠른 추가/취소/실행 속도: 가급적 O(1): 새 주문 넣기, 기존 주문 취소하기, 주문 체결하기 등
    - 빠른 업데이트: 주문 교체 등
    - 최고 매수 호가/최저 매도 호가 질의
    - 가격 수준 순회
- 이중 연결 리스트 활용
    - 모든 삭제 연산이 O(1)에 처리되도록 구현
- O(1) 연산 과정
    1. 새 주문 삽입: PriceLevel 리스트의 마지막에 추가: O(1)
    2. 주문 체결: PriceLevel 리스트의 맨 앞 Order 삭제: O(1)
    3. 주문 취소: 호가 창(OrderBook)에서 Order 삭제
        - 도움 자료 구조 Map<OrderId, Order> orderMap을 활용하여 O(1)에 주문 조회
        - 이중 연결 리스트이므로 Order 안에 이전 주문 가리키는 포인터 있으므로 O(1)에 주문 삭제

#### 봉 차트

- 시작 데이터 프로세서가 시장 데이터 만들 때 호가 창과 더불어 사용하는 핵심 자료 구조
- 하나의 봉이 커버하는 시간 범위가 경과하면, 다음 주기 커버할 새 Candlestick 클래스 객체를 생성하여 CandlestickChart 내부 연결 리스트에 추가하는 방식
- 봉 차트에서 많은 종목의 가격 이력을 다양한 시간 간격으로 추적 시 메모리 많이 필요한데, 최적화할 방법
    1. 미리 메모리를 할당해 둔 링 버퍼에 봉을 보관하여 새 객체 할당 횟수 감소
    2. 메모리에 두는 봉의 개수를 제한하고, 나머지는 디스크에 보관
- 시장 데이터는 일반적으로 실시간 분석을 위해 메모리 상주 칼럼형 데이터베이스 사용
- 시장 마감 후에는 데이터를 이력 유지 전용 데이터베이스에 저장

## 3단계. 상세 설계

### 성능

- 평균 지연 시간은 낮아야 하고, 전반적인 지연 시간 분포는 안정적이어야 한다.
- 지연 시간이 안정적인지 보는 척도: p99 지연 시간
- 지연 시간 줄이는 방법
    1. 중요 경로에서 실행할 작업 수 줄이기
    2. 각 작업의 소요 시간 줄이기
        - 네트워크 및 디스크 사용량 경감
        - 각 작업의 실행 시간 경감
- 중요 경로에서 실행할 작업 수 줄이기
    - 중요 매매 경로: 게이트웨이 -> 주문 관리자 -> 시퀀서 -> 체결 엔진
    - 중요 경로에는 꼭 필요한 구성 요소 외에는 제거
- 각 작업의 소요 시간 줄이기
    - end-to-end 수십 밀리초
        - 핵심 경로 구성 요소가 네트워크를 통해 연결된 개별 서버에서 실행된다고 가정하면, 왕복 네트워크 지연 시간은 약 500 마이크로초
        - 핵심 경로에서 네트워크 통해 통신하는 컴포넌트가 많으면 네트워크 지연 시간은 한 자릿수 밀리초까지 증가
        - 더불어, 시퀀서는 이벤트를 디스크에 저장하는 이벤트 저장소 -> 디스크 엑세스 지연 시간: 수십 밀리초 단위
    - 주로 네트워크 및 디스크 액세스 지연 시간을 줄이거나 없애는 방법으로 end-to-end 지연 시간 줄임. 어떻게?
        - 모든 것을 동일한 서버에 배치하여 네트워크 통신 제거
        - 같은 서버 내 컴포넌트 간 통신은 이벤트 저장소인 mmap을 통함

      <img alt="image" src="https://github.com/user-attachments/assets/5064a3b7-0465-4482-874e-44ea1ab0d157">

#### 이벤트 소싱

- 이벤트 소싱 아키텍처는 현재 상태를 저장하는 대신 상태를 변경하는 모든 이벤트의 변경 불가능한 로그를 유지
- 로그를 절대적 진실의 원천으로 삼음
- 주문 상태를 변경하는 모든 이벤트를 추적하므로, 모든 이벤트를 순서대로 재생하면 주문 상태 복구 가능
- 지연 시간에 대한 엄격한 요구사항으로 kafka 대신, mmap 사용
- 구조
    - 외부 도메인은 FIX를 사용하여 거래 도메인과 통신
    - 게이트웨이는 빠르고 간결한 인코딩을 위해 FIX를 SBE로 변환, 각 주뭉르 이벤트 저장소 클라이언트를 사용하여 미리 정의된 NewOrderEvent 형태로 전송
    - 체결 엔진에 내장된 주문 관리자는 이벤트 저장소로부터 NewOrderEvent를 수신하면 유효성 검사를 한 뒤, 내부 주문 상태에 추가하고, 해당 주문은 처리 담당 CPU 코어로 전송
    - 주문이 체결되면 OrderFilledEvent가 생성되어 이벤트 저장소로 전송
    - 시장 데이터 프로세서 및 보고 서비스 같은 다른 구성 요소는 이벤트 저장소를 구독하고, 이벤트를 받을 때마다 적절하게 처리
- 특징
    - 주문 관리자: 컴포넌트에 **내장**되는 재사용 가능 라이브러리
        - 다른 컴포넌트가 주문 상태 업데이트 또는 질의를 위해 중앙화된 주문 관리자를 이용한다면, 지연 시간은 길어질 것
        - 각 컴포넌트가 주문 상태를 자체적으로 유지하기는 하지만, 이벤트 소싱 아키텍처 특성상 그 모두는 전부 동일하며, 재현 가능
    - 시퀀서: 없어짐!
        - 모든 메시지는 동일한 이벤트 저장소를 사용하며, 이벤트 저장소에 보관되는 항목에는 sequence 필드가 있다.
        - 이 필드는 이벤트 저장소에 있는 시퀀서가 삽입
        - 각 이벤트 저장소에는 하나의 시퀀서만 존재
            - 여러개라면 이벤트 저장소 사용 권한에 대한 경쟁 발생
        - 해당 시퀀서는 각 컴포넌트에 고유한 링 버퍼에서 이벤트를 가져와 순서 ID를 찍은 다음 이벤트 저장소로 전송

### 고가용성

- 고려 사항
    1. 거래소 아키텍처의 SPOF 식별
    2. 장애 감지 및 백업 인스턴스로의 장애 조치 결정이 신속해야 함
- 무상태 서비스(클라이언트 게이트웨이 등): 수평적 확장 가능
- 상태 서비스(주문 관리자, 체결 엔진): 사본 간 데이터 복사가 가능해야 함
    - 부 체결 엔진: 동일한 이벤트를 수신하고 처리하지만 이벤트 저장소로 이벤트를 전송 X
    - 주 체결 엔진이 다운되면 부 체결 엔진이 승격되어 이벤트 전송
    - 부 체결 엔진이 다운되면 일단 재시작 후, 이벤트 저장소 데이터를 활용해 모든 상태 복구
    - 주 체결 엔진의 문제 자동 감지 메커니즘 필요
        - 하드웨어, 프로세스 모니터링 방안
        - 체결 엔진과 박동 메시지를 주고 받는 방안
- 단일 서버 내에서의 동작
    - 여러 서버 또는 데이터 센터 전반으로 확장 필요
    - 주/부 체결 엔진 -> 주/부 서버의 클러스터
        - 주 서버의 이벤트 저장소는 모든 부 서버로 복제해야 함
        - 안정적 UDP를 사용하여 모든 부 서버에 이벤트 메시지를 효과적으로 브로드캐스트

### 결함 내성

- 그럼에도 모두 다운되면?
- 고려사항
    1. 주 서버가 다운되면 언제, 그리고 어떻게 부 서버로 자동 전환하는 결정을 내리나?
    2. 부 서버 가운데 새로운 리더는 어떻게 선출하는가?
    3. 복구 시간 목표는 얼마인가?
    4. 어떤 기능을 복구해야 하는가? 시스템이 성능 저하 상태로도 동작할 수 있는가?

- 주 서버가 다운되면 언제, 그리고 어떻게 부 서버로 자동 전환하는 결정을 내리나?
    - 장애가 생겼다?
        1. 시스템에서 잘못된 경보를 전송하면 불필요한 장애 극복 절차(부 시스템으로의 자동 전환) 발생 가능
        2. 코드의 버그로 인해 주 서버가 다운되었다면 부 서버로 자동 전환되더라도 같은 버그 때문에 부 서버까지 다운될 수 있다.
    - 초반에는 수동으로 장애 복구 조치
    - 충분한 시그널, 운영 경험을 축적하여 시스템에 자신이 생기면 그때 자동화
- 부 서버 가운데 새로운 리더는 어떻게 선출하는가?
    - Raft 알고리즘 등 알려진 리더 선출 알고리즘이 많음
- 복구 시간 목표는 얼마인가?
    - 복구 시간 목표: 애플리케이션이 다운되어도 사업에 심각한 피해가 없는 시간의 최대 값
    - 증권 거래소는 2등급 RTO를 달성해야 함 -> 서비스의 자동 복구가 반드시 가능해야 함
    - 우선순위에 따라 서비스를 분류하고, 최소 서비스 수준을 유지하기 위한 성능 저하 전략을 정의
- 어떤 기능을 복구해야 하는가? 시스템이 성능 저하 상태로도 동작할 수 있는가?
    - 복구 지점 목표: 비즈니스에 심각한 피해가 발생하기 전에 손실될 수 있는 데이터 양, 손실 허용 범위를 의미
    - 데이터는 자주 백업해야 한다는 뜻
    - 증권 거래소는 데이터 손실을 용납할 수 없음: RPO = 0
    - 래프트 메커니즘을 사용하면 데이터 사본은 많음, 모든 클러스터 노드가 같은 상태를 가지도록 보장할 수 있음
    - 빠르게 새로운 리더 선출하여 중단 없이 작업 가능

### 체결 알고리즘

- FIFO 체결 알고리즘: 특정 가격 수준에서 먼저 들어온 주문이 먼저 체결
- LMM(Lead Market Maker) + FIFO 체결 알고리즘: 먼저 들어온 것보다, LMM에 먼저 일정 수량 할당
    - 그 비율은 LMM 회사가 거래소와 협상하여 결정

### 결정론

- 기능적 결정론
    - 이벤트 소싱 아키텍처를 도입하여 이벤트를 동일한 순서로 재생하면 항상 같은 결과를 얻을 수 있도록 보장
    - 중요한 건 실행 시간이 아닌 순서
- 지연 시간 결정론
    - 각 거래의 처리 시간이 거의 같다는 뜻
    - 측정 방법: p99나 99.99번 백분위수 지연 시간 재기
    - p99 지연 시간 낮다 == 거래소의 거의 모든 거래에 안정적인 성능ㅇ르 제공한다
    - 지연 시간 변동 폭이 커지면 원인을 조사해야 함

### 시장 데이터 게시 서비스 최적화

- 시장 데이터 게시 서비스: 체결 엔진의 체결 결과를 받아 이를 기반으로 호가 창과 봉 차트를 재구축한 다음 구독자에게 데이터를 publish
- 링 버퍼를 활용
    - 앞과 끝이 연결된 고정 크기 큐
    - 생산자는 계속 데이터를 넣고, 하나 이상으 ㅣ소비자는 데이터를 꺼냄
    - 링 버퍼의 공간은 사전에 할당된 것으로, 객체 생성/삭제 연산은 필요 없다는 뜻
    - 락을 사용하지 않음

### 시장 데이터의 공정한 배포

- 거래소에서 다른 사람보다 지연 시간이 낮다면, 미래 예측 가능함과 같은 뜻
- 모든 수신자가 동시에 시장 데이터를 받을 수 있도록 보장하는 것이 중요
- 방법
    - 안정적 UDP를 사용하는 멀티 캐스트: 한 번에 많은 참가자에게 업데이트를 브로드캐스트 하기 좋은 솔루션
    - 구독자가 연결하는 순서로 데이터를 주는 대신, 무작위 순서로 전달

#### 멀티캐스트

- 유니캐스트: 1:1
- 브로드 캐스트: 1:ALL
- 멀티 캐스트: 1:NOT ALL
- 거래소 설계에 보편적으로 이용되는 것은 멀티 캐스트: 같은 멀티 캐스트 그룹에 속한 수신자는 이론적으로 동시에 데이터 수신
- But, UDP는 신뢰성이 낮은 프로토콜 -> 재전송 방안 필요

### 코로케이션

- 많은 거래소가 헤지 펀드 또는 브로커의 서버를 거래소와 같은 데이터 센터에 둘 수 있도록 하는 코로케이션 서비스를 제공
- 체결 엔진에 주문을 넣는 지연 시간은 전송 경로 길이에 비례
- 코로케이션 서비스가 공정성을 훼손하지는 않음

### 네트워크 보안

- 거래소는 일반적으로 몇 가지 인터페이스를 공개하고 있으므로 DDoS 공격에 대응할 수 있는 능력 필요
- 사용 기술
    1. 공개 서비스와 데이터를 비공개 서비스에서 분리하여 DDoS 공격이 가장 중요한 클라이언트에 영향을 미치지 않도록 처리, 동일한 데이터 제공해야하면 사본 만들어 문제를 격리
    2. 자주 업데이트 되지 않는 데이터는 캐싱, 질의가 데이터베이스에 영향이 없도록
    3. URL 강화: 질의 문자열 변형 불가능하도록, 혹은 CDN 캐싱 활용
    4. 효과적인 허용/차단 리스트 메커니즘 사용(많은 네트워크 게이트웨이 제품이 제공하는 기능)
    5. 처리율 제한 기능 사용

## 4단계. 마무리

- 대형 거래소를 위한 이상적인 배포 모델 == All In One
