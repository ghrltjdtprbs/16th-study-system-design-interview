# 전자지갑
## 1. 요구사항 요약
- 전자지갑 간 이체
- 1,000,000 TPS 처리 성능
- 99.99% 안정성
- 트랜잭션 
- 재현성

이러한 요구사항을 만족시키기 위해 분산 시스템 설계 및 트랜잭션 일관성 보장 기법을 적용

---

## 2. 분산 트랜잭션

### 2.1 Two-Phase Commit (2PC)

**절차**

1. **Prepare 단계**: 모든 노드에 트랜잭션 실행 가능 여부 확인 요청을 보낸다
2. **Commit 단계**: 모든 노드가 수락 시 실제 커밋을 수행하고, 하나라도 거부하면 전체 롤백을 수행한다

**특징 및 한계**

- 일관성은 강하게 보장되나, 응답 지연 혹은 장애에 매우 취약하다
- 고속 처리를 요구하는 환경에서는 병목이 발생하기 쉽다

---

### 2.2 Try-Confirm/Cancel (TC/C)

**절차**

1. **Try**: 자원을 잠그거나 상태 변경을 시도한다
2. **Confirm**: 모든 Try 성공 시 트랜잭션을 커밋한다
3. **Cancel**: 실패하거나 중단된 경우 보상 트랜잭션을 통해 롤백한다

**특징 및 한계**

- 유연한 구조로 장애 대응에 효과적이다
- 하지만 트랜잭션 순서가 엇갈릴 수 있어 데이터 불일치 가능성이 존재한다

---

### 2.3 Saga 패턴

**절차**

1. 각 작업은 독립적인 로컬 트랜잭션으로 수행된다
2. 실패 시, 역순으로 보상 트랜잭션을 수행하여 전체 롤백을 유도한다

**특징 및 한계**

- 높은 성능과 확장성을 보장하며 장애 시에도 유연하게 복구할 수 있다
- 보상 트랜잭션 설계가 복잡하며 데이터 정합성 유지가 어려울 수 있다

---

## 3. 시스템 설계 핵심 요소

### 3.1 샤딩

- 사용자 계정을 여러 노드에 균등하게 분산한다
- 단일 노드의 부하를 줄이고 전체 처리량을 향상시킬 수 있다
- 단일 트랜잭션이 다수 노드를 포함할 수 있으므로 분산 트랜잭션 전략이 필요하다

---

### 3.2 이벤트 소싱 + CQRS

**이벤트 소싱**

- 모든 상태 변경을 이벤트로 기록하여 상태를 재구성할 수 있도록 한다
- 이벤트는 불변이며 결정론적 로직을 통해 항상 동일한 결과를 도출할 수 있다

**CQRS**

- 명령(Command)과 조회(Query)를 분리하여 확장성과 성능을 향상시킨다
- 읽기 전용 상태 기계는 다양한 형태로 조회 모델을 구성할 수 있다

---

### 3.3 합의 알고리즘 (Raft)
- 리더 장애 발생 시 자동으로 새로운 리더를 선출한다
- 로그 순서와 데이터 무결성을 보장하며 장애 복구에 유리하다

---

### 3.4 고성능 이벤트 저장

- 파일 기반 명령 및 이벤트 목록을 디스크에 저장하고, 메모리 캐싱을 병행한다
- RocksDB, SQLite 등을 활용하여 상태 데이터도 안전하게 관리한다
- 주기적인 스냅샷으로 재구성 시간을 단축할 수 있다

---

## 4. 설계 요약

| 요구사항        | 설계 전략                               |
|----------------|----------------------------------------|
| 1,000,000 TPS  | 인메모리 샤딩 + CQRS + 이벤트 소싱       |
| 99.99% 안정성  | Raft 합의 + 파일 기반 로그 복제          |
| 재현성         | 이벤트 소싱 + 상태 머신 + 스냅샷         |
| 트랜잭션 보장  | Saga 또는 TC/C 기반 분산 트랜잭션 방식   |

---

