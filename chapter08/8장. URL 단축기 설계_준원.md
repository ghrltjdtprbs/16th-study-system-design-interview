# 8장 - URL 단축기 설계

## 1단계 - 문제 이해 및 설계 범위 확정
- 모호함을 줄이고 요구 사항 이끌어 내기
  - Q) URL 단축기가 어떻게 동작해야하는지 예제를 보여줘
    - A) https://www.naver.com/q=asdasd&c=asdasd&v=asdasd 와 같은 입력이 있을 때, https://tinyurl.com/abc1234 와 같은 형태로 변환해야 함.
  - Q) 트래픽 규모는?
    - A) 매일 1억(100million) 개의 URL을 단축해야 함.
  - Q) 단축 URL의 길이는 어느 정도여야 하는가?
    - A) 짧으면 짧을 수록 좋다.
  - Q) 단축 URL에 포함될 문자에 제한이 있는가?
    - A) 단축 URL에는 숫자(0부터 9까지)와 영문자(a부터 z, A부터 Z까지)만 사용 가능
  - Q) 단축 URL을 시스템에서 지우거나 갱신할 수 있는가?
    - A) 시스템을 단순화하기 위해 삭제하거나 갱신 할 수 없다고 가정
- 시스템의 기본적인 기능
  - URL 단축
    - 주어진 긴 URL을 짧게 줄인다
  - URL 리디렉션(redirection)
    - 단축된 URL로 HTTP 요청이 오면 원래 URL로 안내
  - 높은 가용성과 규모 확장성, 장애 감내가 요구됨

### 개략적 추정
- 쓰기 연산
  - 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산
  - 1억/24/3600 = 1160
- URL 단축 서비스를 10년간 운영한다고 가정하면 1억 * 365 * 10 = 3650억 개의 레코드를 보관해야 함
- 축약 전 URL의 평균 길이는 100이라고 하면
  - 10년 동안 필요한 저장 공간은 3650억 * 100바이트 = 36.5TB

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- API 엔드포인트, URL 리디렉션, URL 단축 플로우에 대해 학습

### API 엔드포인트
- 필요한 엔드포인트
  - URL 단축용 엔드포인트
    - 단축할 URL을 담아서 POST 요청
    - POST /api/v1/data/shorten
    - 인자
      - {longUrl: longURLString}
    - 반환
      - {shortUrl: shortURLString}
  - URL 리디렉션용 엔드포인트
    - 단축된 URL을 받아서 리디렉션
    - GET /api/v1/shortUrl
    - 반환
      - 원래 URL

### URL 리디렉션
- 단축 URL을 받으면 원래 URL로 바꿔서 301 응답의 Location 헤더에 담아 반환
- 301 Permanently Moved
  - 해당 URL에 대한 HTTP 요청의 처리 책임이 **영구적**으로 Location 헤더에 반환된 URL로 이전
  - 영구적으로 이전되었으므로, 브라우저는 이 응답을 **캐시**함
    - 같은 단축 URL 요청 시 브라우저는 ㅐ시된 원래 URL로 요청을 보냄
  - 서버 부하 감소
  - 트래픽 분석이 어려움
- 302 Found
  - 해당 URL에 대한 요청이 **일시적**으로 Location 헤더에 반환된 URL로 이전
  - 항상 단축 URL 서버를 거친 후 원래 URL로 리디렉션\
  - 클릭 발생률이나 발생 위치 추적에 유리
- 해시 테이블을 사용한 구현
  - <단축 URL, 원래 URL> 쌍을 저장
  - 가장 직관적
  - 원래 URL = hashTable.get(단축 URL)
  - 301 또는 302 응답 Location 헤더에 원래 URL을 넣어 전송

### URL 단축
- 긴 URL을 해시 값으로 대응 시킬 해시 함수를 찾아야 함
- 해시 함수가 만족해야 할 요구 사항
  - 입력으로 주어진 긴 URL이 다른 값이면 해시 값도 달라야 한다.
  - 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.

## 3단계 - 상세 설계
### 데이터 모델
- 해시 테이블의 문제점
  - 메모리는 유한하며 비싸다
- <단축 URL, 원래 URL> 쌍을 저장하는 데이터베이스를 사용

### 해시 함수
- 원래 URL을 단축 URL로 변환하는 데 사용

### 해시 값 길이
- 사용할 수 있는 문자
  - [0-9, a-z, A-Z]
  - 10 + 26 + 26 = 62개
  - 62^n >= 3650억 인 n의 최솟값을 찾아야 함
  - 62^6 = 56_800_235_584
  - 62^7 = 3_521_614_606_208
  - 62^8 = 218_340_105_584_896
  - 따라서 hashValue의 길이는 7이 적당함

### 해시 후 충돌 해소
- https://en.wikipedia.org/wiki/Systems_design 축약
  - CRC32
    - 5cb54054
  - MD5
    - 5a62509a84df9ee03fe1230b9df8b84e
  - SHA-1
    - 0eeae7916c06853901d9ccbefbfcaf4de57ed85b
- 가장 짧은 CRC32조차도 7자리를 넘음.
  - 해시 값에서 처음 7자만 사용
    - 충돌할 확률 증가
    - 충돌 시 충돌이 해소될 때가지 사전에 정한 문자열을 해시값에 덧붙임
    - 매번 DB 질의가 들어가야 하므로 오버헤드가 큼
    - 블룸 필터를 사용하면 성능을 높일 수 있음

### base-62 변환
- 진법 변환은 URL 단축기를 구현 시 흔히 사용되는 접근법 중 하나
- 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야하는 경우 유용함
- 62진법을 사용하는 이유는 hashValue에 사용할수 있는 문자가 62개이기 때문

### 해시 후 충돌 해소 vs base-62 변환
해시 후 충돌 해소 | base-62 변환
--- | ---
단축 URL의 길이가 고정됨 | 단축 URL의 길이가 가변적. ID와 비례함
유일성이 보장되는 ID 생성기 불필요 | 유일성 보장 ID 생성기 필요
충돌이 가능해서 충돌 해결 전략 필요 | ID 유일성이 보장되어야 적용 가능하므로 충돌이 없음
ID로부터 단축 URL을 계산하는 것이 아니라 다음 사용 가능한 URL 찾아내는 것 불가능 | ID가 1씩 증가하는 값이라고 가정하면 다음 쓸 수 있는 단축 URL을 찾아낼 수 있음 -> 보안상 문제 가능성

### URL 단축기 상세 설계
1. 입력으로 긴 URL을 받음
2. DB에 해당 URL 검사
3. URL 존재
   - DB의 URL을 반환
4. URL 존재하지 않음
   - 유일한 ID를 생성, DB의 기본 키로 사용
   - 62진법 변환을 적용, ID를 단축 URL로 만듦
   - DB에 저장 후 단축 URL 반환

## 4단계 - 마무리
- 추가적인 논의 사항
  - 처리율 제한 장치
    - 엄청난 양의 URL 단축 요청이 밀려들 경우 무력화될 수 있음.
    - IP 주소 등의 필터링 규칙같은 기능 필요
  - 웹 서버의 규모 확장
    - 웹 계층은 무상태 계층임.
    - 웹 서버를 자유로이 증설하거나 삭제할 수 있음.
  - DB 규모 확장
    - DB를 다중화하거나 샤딩해 규모 확장 가능
  - 데이터 분석 솔루션
    - URL 단축기에 데이터 분석 솔루션을 통합해 정보 분석 가능
  - 가용성, 데이터 일관성, 안정성
    - 대규모 시스템이 성공적으로 운영되기 위해 필수 조건

### URL 단축키의 필요성
- UX 향상
  - 공유가 쉬워짐
  - 링크 클릭 확률을 높일 수 있음